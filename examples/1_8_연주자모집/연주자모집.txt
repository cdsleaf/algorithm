오케스트라 연주자 모집

오케스트라(orchestra)는 여러 악기의 연주자들이 함께 관현악곡을 연주하는 단체이다.
오케스트라는 현악기, 목관악기, 금관악기, 타악기, 건반악기의 여러 종류의 많은 악기로
구성이 되며 그에 따라 많은 연주자들이 필요하다. 현재 어떤 오케스트라에서 
예비 연주자가 필요한 악기들에 대해서 연주자를 뽑으려 하고 혼자서 다양한 악기를 
연주할 수 있는 많은 연주자들이 지원을 하였다. 이에 오케스트라는 예비 연주자가 
필요한 모든 악기들에 대해서 최소 한 명 이상의 연주 가능자가 있도록 하는 조건을 
만족하면서 채용하는 연주자들의 월급의 합이 최소가 되도록 지원자들 중에서 연주자들을 
뽑으려 한다. 즉, 현재 필요한 모든 악기 별로 한 명씩 연주자를 뽑는 것이 아니라 지원자의 
연주 가능한 악기 목록을 보고 악기 별로 연주 가능자가 한 명 이상 되도록 연주자들을 뽑는 
것이다. 예를 들어, 현재 바이올린, 비올라, 첼로, 콘트라베이스 연주자를 추가로 
모집하려고 하고 있고 5명의 A, B, C, D, E의 지원자가 지원을 하였다. 지원자 A는 
바이올린과 콘트라베이스를, 지원자 B는 바이올린과 비올라를, 지원자 C는 바이올린과 
첼로를, 지원자 D는 콘트라베이스를, 지원자 E는 첼로를 연주할 수 있다고 하며 
각 연주자 별 월급은 알파벳 순서대로 1000만원, 500만원, 900만원, 300만원, 500만원이라고 한다. 
이 때 연주자 A, B, C를 뽑게 되면 바이올린, 비올라, 첼로, 콘트라베이스의 연주 가능자가 
모두 한 명 이상씩 되면서 2400만원이 월급의 합이 된다. 
그러나 연주자 B, D, E를 뽑게 되면 같은 조건을 만족하면서 1300만원이라는 최소의 월급 합이 된다. 
지원자의 수 N과 예비 연주자가 필요한 악기의 수 M, 
그리고 지원자들의 월급과 연주 가능한 악기 정보가 주어질 때 오케스트라가 악기 별 연주 가능자가 
한 명 이상씩 되도록 하면서 최소의 월급의 합으로 연주자를 뽑는 경우의 월급의 합을 출력하는 
프로그램을 작성하시오. 
단, 각 악기를 연주할 수 있는 지원자는 최소 1명 이상으로 주어지며 
모든 지원자는 최소 하나 이상의 악기를 연주가능 하도록 주어진다.

지원자들이 연주 가능한 악기의 정보는 다음의 표1과 같이 주어진다.

    [표 1]
              A  B  C  D  E
바이올린      1  1  1  0  0
비올라        0  1  0  0  0
첼로          0  0  1  0  1
콘트라베이스  1  0  0  1  0

즉, 행렬의 형태로 주어지며 i행의 j열 값은 j지원자가 i악기의 연주 가능 여부를 나타낸다. 
값이 1인 경우 j지원자가 i악기를 연주할 수 있음을 의미하며, 0인 경우 연주할 수 없음을 의미한다.


[제한 조건]
지원자의 수 N은 5 이상 20 이하의 정수이다.
악기의 수 M은 4 이상 24 이하의 정수이다.

[입력]
최초 테스트케이스의 개수 T가 주어지며 다음 줄부터 T개의 테스트 케이스가 주어진다. 
각 테스트 케이스는 여러 줄로 구성이 되며 첫 줄에는 지원자의 수 N과 악기의 수 M이 
공백으로 구분되어 주어진다. 다음 줄에는 지원자 별 월급이 공백을 사이에 두고 주어지고 
그 다음 M줄에는 지원자들의 연주 가능한 악기 정보가 M × N 행렬의 형태로 주어진다. 
이 행렬의 i번째 행에서 j번째 열에 있는 원소는 지원자 j가 i악기를 연주 가능한 경우 1로 주어지며, 
그렇지 않은 경우 0으로 주어진다.

[출력]
각각의 테스트 케이스에 대하여 #x(x는 테스트 케이스 번호를 의미)를 출력하고 공백을 하나 둔 다음 
조건을 만족하는 월급합의 최소값을 출력한다.

[입출력 예제]
입력
4				// 테스트 케이스의 수
5 4				// 테스트 케이스 #1
1000 500 900 300 500 
1 1 1 0 0 
0 1 0 0 0 
0 0 1 0 1 
1 0 0 1 0 
5 4				// 테스트 케이스 #2
700 300 800 600 200 
0 1 0 1 0 
0 0 1 0 1 
1 0 0 0 0 
0 0 0 1 0 
5 4				// 테스트 케이스 #3
200 200 1000 400 600 
1 0 0 0 0 
1 0 0 1 0 
1 0 0 0 1 
0 1 1 1 0
10 8				// 테스트 케이스 #4
200 300 400 500 600 500 400 600 700 200 
1 0 0 0 1 1 0 0 0 1 
0 0 1 0 0 0 0 1 1 0
0 1 0 1 0 0 1 0 0 0
1 0 0 0 0 1 0 0 1 0
0 0 0 1 0 0 0 1 0 1
0 1 0 0 0 0 1 0 0 0
0 0 0 1 0 0 0 0 1 0
0 1 0 0 0 0 1 0 0 0

출력
#1 1300
#2 1500
#3 400
#4 1200
